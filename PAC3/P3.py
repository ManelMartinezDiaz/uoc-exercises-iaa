#P3.py
#Continuous Assesment Test main file

import random
import analyzer
import numpy as np
import matplotlib.pyplot as plt
from deap import creator,base,tools,algorithms
from functools import reduce

def fulfill_constraints(max_imagery=1000, min_imagery_type=10):
    def decorator(func):
        def wrapper(*args, **kargs):
            offspring = func(*args, **kargs)

            for child in offspring:

                decoded_child = list(analyzer.decode(child))
                #decoded_child = list(analyzer.decode_trivial(child))


                ####################
                ####Exercise 2c#####
                ####################

                # TO DO: here 'child' is an individual generated by DEAP (child[i] is a 'gene'
                # of this individual). You need to force
                # it to fulfill the problem requirements, taking care of the coding you chose
                # At the end, every child must contain a coded individual that fulfills
                # the requirements of max_imagery and min_imagery_type

                # HINT: use the decoded_child to work with it with ease.
                # First, focus on the min_imagery_type constraint
                # Second, focus on max_imagery constraint
                # Finally, you will need to encode back the individual before modifying the child array
                # You can use as many vars as you want, of course
                new_child = []
                

                #firstly, minimum 10 images per image type
                for i in range(0,len(decoded_child)):
                    # remove the 'pass' instruction and complete this loop as you need
                    if decoded_child[i] < 10:
                        #print("MinDectedted: ",decoded_child[i])
                        
                        #print("Decoded_child. N_Images["
                      #,sum(decoded_child),"] "
                      #,decoded_child[0]," "
                      #,decoded_child[1]," "
                      #,decoded_child[2]," "
                      #,decoded_child[3]," "
                      #,decoded_child[4]," ")
                                        
                        decoded_child[i] = random.randint(10, 255)
                        
                      #  print("Decoded_child_revised. N_Images["
                      #,sum(decoded_child),"] "
                      #,decoded_child[0]," "
                      #,decoded_child[1]," "
                      #,decoded_child[2]," "
                      #,decoded_child[3]," "
                      #,decoded_child[4]," ")
                                        

                #secondly, max amount of images: 1000
                while sum(decoded_child) > max_imagery:
                   # print("MaxDectedted: ",sum(decoded_child))
                    
                    #print("Decoded_child. N_Images["
                    #  ,sum(decoded_child),"] "
                    #  ,decoded_child[0]," "
                    #  ,decoded_child[1]," "
                    #  ,decoded_child[2]," "
                    #  ,decoded_child[3]," "
                    #  ,decoded_child[4]," ")
                                            
                    # remove the 'pass' instruction and complete this loop as you need
                    #Recorre els diferents n√∫meros d'imatges i assignar valors aleatoris entre 10 i 255
                    for i in range(0,len(decoded_child)):
                        decoded_child[i] = random.randint(10, 255)

                    #print("Decoded_child_revised. N_Images["
                    #  ,sum(decoded_child),"] "
                    #  ,decoded_child[0]," "
                    #  ,decoded_child[1]," "
                    #  ,decoded_child[2]," "
                    #  ,decoded_child[3]," "
                    #  ,decoded_child[4]," ")
                        
                #for i in range(0, len(child)):
                    # remove the 'pass' instruction and
                    # do the necessary actions (inside and/or outside this loop) to get the new_child
                    # as the encoded representation of the new individual, which fulfills the requirements
                    
                    
                new_child = analyzer.encode(decoded_child)    

                # offspring's child modification
                # encode back your decoded individual before entering this loop!!!
                for i in range(0, len(child)):
                    child[i] = new_child[i]
                    

            return offspring
        return wrapper
    return decorator


#Implement GA. Prepare deap: initialization, definition of strategies

#GA initialization

# Create the item dictionary: item name is an integer, and value is
# a (weight, value) 2-uple.
#ITEMS_NAME = "RGB", "term", "IR", "RADAR", "LiDAR"
#ITEMS_NAME2 = 1,2,3,4,5

#items = {}
#Create the item dictionary: item name is an integer an value is the number of images
#for i in ITEMS_NAME2:
#    items[i] = (ITEMS_NAME2[i], random.randint(0, 255))
    

ITEMS_NAME = "RGB", "term", "IR", "RADAR", "LiDAR"
#IMAGES = (1, 2, 3, 3, 4)
#ITEMS = dict(
#            (name, (images, random.uniform(1, 5))) 
#            for name, images in zip(ITEMS_NAME, IMAGES)
#        )   

creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
creator.create('Individual', list, fitness=creator.FitnessMin)
#creator.create('Individual', set, fitness=creator.FitnessMin)
#creator.create('Individual', np.ndarray, fitness=creator.FitnessMin)

toolbox = base.Toolbox()

####################
####Exercise 2a#####
####################

#TO DO: Complete the following sentences to prepare your GA algorithm
#Register the attributes, individuals, population... according to your individual coding
#toolbox.register('attrImageType', random.randint, 0, 4)
toolbox.register('attr_numberImages', random.randint, 0, 255)
#toolbox.register(, , , )
toolbox.register('individual', tools.initRepeat, creator.Individual, 
                 #(toolbox.attr_typeImage,toolbox.attr_numberImages),
                 toolbox.attr_numberImages,
                 n=10)
toolbox.register('population', tools.initRepeat, list, toolbox.individual)

#GA strategies definition
#Objective function is analyzer.analyze_performance
objective_function = analyzer.analyze_performance

#TO DO: Complete the following sentences to prepare your GA algorithm
#Register the GA operations

toolbox.register('evaluate', objective_function)
toolbox.register('mate', tools.cxTwoPoint)
toolbox.register('mutate',tools.mutShuffleIndexes , indpb=0.1)
toolbox.register('select', tools.selTournament, tournsize=3)


#GA decoration

###############################
####Exercise 2 - final step####
###############################
# TO DO: uncomment the following 3 lines
toolbox.decorate('population', fulfill_constraints())
toolbox.decorate('mate', fulfill_constraints())
toolbox.decorate('mutate', fulfill_constraints())

#run the GA
population = toolbox.population(25)
print(population)

NGEN = 20
cx_prob = 0.5
mut_prob = 0.2

for gen in range(NGEN):

    offspring = algorithms.varAnd(population, toolbox, cxpb=cx_prob, mutpb=mut_prob)
    fits = toolbox.map(toolbox.evaluate, offspring)

    for fit,ind in zip(fits, offspring):
        ind.fitness.values = fit

    population = toolbox.select(offspring, k=len(population))
    top = tools.selBest(population, k=1)
    fitness = objective_function(top[0])
    ####################
    ####Exercise 2######
    ####################
    # TO DO: replace the call to 'decode_trivial' with a call to the function 'decode' that you just implemented
    #print("Decode_Trivial: ", gen, fitness, analyzer.decode_trivial(top[0]), top[0])
    print("Decode: ", gen, fitness, analyzer.decode(top[0]), top[0])
    ####################
    ####Exercise 4######
    ####################
    # TO DO: Save the best fitness somehow, so that you can plot them later

# TO DO: plot some charts to assess how the error behaves over generations
# you can use x as the x axis list (this may help you plot)
x = list(range(NGEN))
#...




